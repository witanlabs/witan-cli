# Proposal v2: `witan mcp` with One `xlsx_exec` Tool

## Decision

Ship an MCP server in this CLI with one tool: `xlsx_exec`.

- Path-based workbooks only for MVP.
- No workbook handles in MVP.
- No `post.verify` in schema; verification stays inside exec scripts (`xlsx.lint(wb)`, etc.).
- Save modes are explicit: `read_only | inplace | save_as` (`read_only` default).
- Optional render output is an inline MCP image content block so the model can see the sheet in the same response.
- MVP consistency rule: `render` requires `save_mode != "read_only"` so render always reflects post-exec workbook state.
- Use the official MCP Go SDK: `github.com/modelcontextprotocol/go-sdk` at `v1.3.1`.

This keeps the API minimal and aligns with Code Mode: one powerful execution primitive plus strong tool guidance.

## Why This Is Still High-Leverage

- MCP distribution reduces onboarding friction to one config entry.
- Binary safety is preserved: workbook bytes never appear in tool args/results.
- Existing CLI/API logic already covers most of the hard parts (`exec`, write-back, auth modes, retries).
- Inline image blocks provide a clear advantage over plain CLI workflows for visual verification.

## MVP Scope

- New command: `witan mcp` (stdio JSON-RPC MCP server).
- One tool: `xlsx_exec`.
- Workbook selector: top-level `path` only.
- Save behavior:
  - `read_only`: do not write workbook bytes to disk
  - `inplace`: overwrite input workbook if writes were produced
  - `save_as`: write updated workbook to `output_path`
- Optional render:
  - if `render` is provided, return image as MCP image content block in the same tool response
- MCP prompts:
  - expose `xlsx-code-mode` and `xlsx-verify` skill content via `prompts/list` and `prompts/get`

## Out of Scope (MVP)

- Workbook handles/session store.
- Additional top-level tools (`xlsx_render`, `xlsx_verify`).
- Schema-level `post.verify`.
- Passing workbook bytes over MCP.

## MCP Tool Description (Critical for Agent Success)

The tool description should be treated as the built-in skill:

```text
Execute JavaScript against a local Excel workbook (.xls/.xlsx/.xlsm) using Witanâ€™s spreadsheet runtime.

Runtime globals:
- wb: the opened workbook context
- xlsx: spreadsheet API helpers
- input: JSON input object
- print(...): captured stdout

Common methods:
- await xlsx.readCell(wb, "Sheet!A1")
- await xlsx.setCells(wb, [{ address: "Inputs!B5", value: 1.1 }])
- await xlsx.findCells(wb, "Revenue", { context: 1 })
- await xlsx.lint(wb)
- await xlsx.detectTables(wb)
- await xlsx.tableLookup(wb, { table: "Revenue", rowLabel: "Q1", columnLabel: "Actual" })
- await xlsx.getCellDependents(wb, "Model!E12", 2)
- await xlsx.traceToInputs(wb, "Model!E12")
- await xlsx.evaluateFormula(wb, "Model", "=NPV(B1,B2:B10)")

Use save_mode=read_only for analysis, inplace to overwrite the file, or save_as to write to a new path.
Optional render returns an inline image block in the same MCP response.

Constraints:
- No imports in exec code
- timeout_ms/max_output_chars are supported
- Workbook path must exist on the local filesystem

Full API reference:
- https://github.com/witanlabs/witan-cli/blob/main/skill/xlsx-code-mode/SKILL.md
```

## `xlsx_exec` Tool Contract

### Input schema (proposed)

```json
{
  "path": "/abs/or/relative/report.xlsx",
  "code": "return await xlsx.readCell(wb, \"Summary!A1\");",
  "input": {},
  "timeout_ms": 0,
  "max_output_chars": 0,
  "save_mode": "read_only",
  "output_path": "/tmp/report-edited.xlsx",
  "render": {
    "range": "Summary!A1:H20",
    "dpr": 2,
    "format": "png"
  }
}
```

Rules:

- `path` and `code` are required.
- `save_mode` is optional and defaults to `read_only`.
- if set, `save_mode` must be one of `read_only | inplace | save_as`.
- `output_path` is required only when `save_mode == "save_as"`.
- `render` is optional.
- `render.format` MVP: `png` only.
- `render` requires `save_mode` to be `inplace` or `save_as` in MVP.
- `timeout_ms` and `max_output_chars`: `0` means default behavior.

### Output behavior (proposed)

Tool result returns both:

- a text content block containing structured JSON summary
- optionally, an image content block when `render` is requested

Example MCP tool result:

```json
{
  "content": [
    {
      "type": "text",
      "text": "{\"ok\":true,\"execution\":{\"ok\":true,\"writes_detected\":true}}"
    },
    {
      "type": "image",
      "mimeType": "image/png",
      "data": "<base64-png>"
    }
  ]
}
```

Notes:

- The model should never construct or parse workbook base64.
- The image block is generated by the MCP server and consumed by MCP clients as image content.
- Workbook binaries remain path-based and local.
- The text summary includes the full exec envelope fields (`ok`, `stdout`, `truncated`, `result`, `writes_detected`, `accesses`, `error`) without MCP-layer trimming.

### Partial success semantics

- If exec fails (`execution.ok=false`):
  - return text block with exec failure details
  - do not attempt render
  - no image block
- If exec succeeds and render fails:
  - return text block with exec success plus `render.ok=false` and render error details
  - no image block
  - do not discard exec outputs
- If exec succeeds and render succeeds:
  - return text block (`render.ok=true`) + image block

## Architecture

### New command

- Add `cmd/mcp.go` with `mcpCmd` registered under root (`witan mcp`).
- Command runs MCP over stdio using the official SDK.

### SDK choice

- Dependency: `github.com/modelcontextprotocol/go-sdk v1.3.1`.
- Reasoning:
  - maintained by the MCP org/Google
  - stable post-1.0 API
  - built-in stdio transport, tools, prompts, and content block support
  - avoids protocol-layer reimplementation risk

### Internal package layout

- `internal/mcp/server.go`
  - SDK server wiring over stdio transport
  - registers `tools/list`, `tools/call`, `prompts/list`, `prompts/get`
- `internal/mcp/tool_xlsx_exec.go`
  - typed tool input/output structs
  - JSON Schema generation/validation via SDK registration
  - execution flow + content block assembly (`TextContent`, `ImageContent`)
- `internal/mcp/writeback.go`
  - atomic write helper (`temp + rename`)
  - extension fix-up reuse
- `internal/mcp/prompts.go`
  - loads prompt bodies from local skill files:
    - `skill/xlsx-code-mode/SKILL.md`
    - `skill/xlsx-verify/SKILL.md`

### Reuse from existing code

- `client.New(...)`, `Exec`, `FilesExec`, `EnsureUploaded`, `ReuploadFile`, `DownloadFileContent`, `UpdateCachedRevision`
- existing auth/stateless resolution in `cmd/root.go`
- extension normalization helpers in `cmd/xlsx_fixext.go`

## Execution Flow

### 1) Validate and normalize input

- Resolve workbook path to absolute path.
- Validate extension (`.xls`, `.xlsx`, `.xlsm`) and existence.
- Resolve `save_mode` (default `read_only`) and validate mode/output rules.
- Validate `render` options and enforce `render` + `read_only` incompatibility in MVP.

### 2) Run exec request

- Build `client.ExecRequest` from `code`, `input`, and limits.
- Determine `saveRequested := save_mode != "read_only"`.
- Execute through existing stateful/stateless branch.
- Handle stale file cache by retrying with `ReuploadFile` on 404 in files-backed mode.

### 3) Write back if requested

- If `save_mode == "read_only"`: never write workbook bytes.
- If `save_mode == "inplace"`: write updated bytes to original path (atomic).
- If `save_mode == "save_as"`: write updated bytes to `output_path` (atomic).
- For stateless responses, decode returned workbook base64 internally.
- For files-backed responses, download revision bytes internally.

### 4) Optional render

- If `render` provided, call render endpoint against the effective workbook path.
- Convert image bytes to MCP image content block (`mimeType=image/png`, `data=base64`).
- Attach image block to the same tool response.
- If render fails after exec success, preserve exec output and return a partial-success text block with render error metadata.

### 5) Return MCP response

- First content block: structured JSON summary (`ok`, full execution envelope, write details, output path if any, render status).
- Optional second content block: inline image.

## Error Model

Use stable structured errors:

- `INVALID_ARGUMENT`
- `WORKBOOK_NOT_FOUND`
- `EXEC_FAILED`
- `WRITEBACK_FAILED`
- `RENDER_FAILED`
- `UPSTREAM_API_ERROR`

Each includes:

- `code`
- `message`
- `retryable`
- `details` (small JSON object, no workbook bytes)

Error handling policy:

- Protocol/validation/path/auth/upstream failures before exec returns as tool error.
- Exec script failures are returned as normal tool result payload (`execution.ok=false`), not MCP transport error.
- Render failures after a successful exec are returned as partial success in the result payload (`render.ok=false`) rather than failing the whole tool call.

## Security and Guardrails

- No workbook bytes in text JSON output.
- Explicit save mode prevents accidental mutation.
- Atomic writes reduce corruption risk.
- Optional env allowlist for paths: `WITAN_MCP_ALLOW_PATHS`.
- Preserve current auth behavior (`--api-key`, env, config, stateless fallback).

## Implementation Plan (2-3 day MVP)

### Day 1

- Add `witan mcp` command and SDK server bootstrap.
- Add dependency `github.com/modelcontextprotocol/go-sdk@v1.3.1`.
- Register `xlsx_exec` with strong description and SDK-backed JSON schema.

### Day 2

- Implement path-based exec flow and `save_mode` (`read_only`, `inplace`, `save_as`).
- Implement optional `render` that returns inline image content block.
- Add structured errors and JSON summary payload.

### Day 3 (hardening)

- Add `prompts/list` and `prompts/get` for `xlsx-code-mode` and `xlsx-verify`.
- Add unit/integration tests and docs.

## Spec Compliance and Test Strategy

### Development

- Use MCP Inspector for iterative tool debugging:
  - `npx @modelcontextprotocol/inspector ./witan mcp`

### CI

- Run automated MCP compliance checks with `Janix-ai/mcp-validator` against stdio server mode.

### Unit tests

- Use SDK in-memory transport/test helpers for fast, in-process protocol tests (no subprocess spawn required).

### Manual compatibility

- Validate with Claude Code local MCP and Cursor MCP config before release.

## Test Plan

### Unit tests

- Input validation:
  - required fields
  - save mode rules
  - render option rules (`render` forbidden with `read_only`)
- Write-back behavior:
  - `read_only` no file mutation
  - `inplace` mutates original
  - `save_as` writes target path
- Error mapping:
  - API/script/write/render failures to stable codes

### Integration tests

- MCP protocol handshake and tool invocation over stdio.
- `xlsx_exec` success/failure responses with structured text block.
- `xlsx_exec` partial success when render fails after exec success.
- Render requests include a valid image content block.
- Prompts endpoints return expected skill text.

### Manual checks

- MCP Inspector
- Claude Code local MCP
- Cursor MCP

## Acceptance Criteria

- Agent can read/write `.xlsx` through MCP without workbook base64 in tool args/results.
- One tool (`xlsx_exec`) supports analysis, mutation, and optional inline visual output.
- Save behavior is explicit via `read_only | inplace | save_as`.
- Tool description is sufficient for first-call success without separate manual skill setup.
- Skill references are available through MCP prompts.
